'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create(indexCfg);window.geekdocSearchIndex=index;index.add({'id':0,'href':'/kubectl-trace/usage/installing/','title':"Installing",'content':"There are a couple ways to install kubectl-trace on your machine.\nKrew You can install kubectl trace using the Krew, the package manager for kubectl plugins.\nOnce you have Krew installed just run:\nkubectl krew install trace You\u0026rsquo;re ready to go!\nPre-built binaries See the release page for the full list of pre-built assets.\nThe commands here show amd64 versions, 386 versions are available in the releases page.\nLinux\ncurl -L -o kubectl-trace.tar.gz https://github.com/iovisor/kubectl-trace/releases/download/v0.1.0-rc.1/kubectl-trace_0.1.0-rc.1_linux_amd64.tar.gz tar -xvf kubectl-trace.tar.gz mv kubectl-trace /usr/local/bin/kubectl-trace OSX\ncurl -L -o kubectl-trace.tar.gz https://github.com/iovisor/kubectl-trace/releases/download/v0.1.0-rc.1/kubectl-trace_0.1.0-rc.1_darwin_amd64.tar.gz tar -xvf kubectl-trace.tar.gz mv kubectl-trace /usr/local/bin/kubectl-trace Windows\nIn PowerShell v5+\n$url = \u0026#34;https://github.com/iovisor/kubectl-trace/releases/download/v0.1.0-rc.1/kubectl-trace_0.1.0-rc.1_windows_amd64.zip\u0026#34; $output = \u0026#34;$PSScriptRoot\\kubectl-trace.zip\u0026#34; Invoke-WebRequest -Uri $url -OutFile $output Expand-Archive \u0026#34;$PSScriptRoot\\kubectl-trace.zip\u0026#34; -DestinationPath \u0026#34;$PSScriptRoot\\kubectl-trace\u0026#34; Source go get -u github.com/iovisor/kubectl-trace/cmd/kubectl-trace This will download and compile kubectl-trace so that you can use it as a kubectl plugin with kubectl trace\nPackages You can\u0026rsquo;t find the package for your distro of choice? You are very welcome and encouraged to create it and then open an issue to inform us for review.\nArch - AUR The official PKGBUILD is on AUR.\nIf you use yay to manage AUR packages you can do:\nyay -S kubectl-trace-git "});index.add({'id':1,'href':'/kubectl-trace/usage/','title':"Usage",'content':""});index.add({'id':2,'href':'/kubectl-trace/usage/cheat-sheet/','title':"Cheat sheet",'content':"You don\u0026rsquo;t need to setup anything on your cluster before using it, please don\u0026rsquo;t use it already on a production system, just because this isn\u0026rsquo;t yet 100% ready.\nRun a program from string literal In this case we are running a program that probes a tracepoint on the node ip-180-12-0-152.ec2.internal.\nkubectl trace run ip-180-12-0-152.ec2.internal -e \u0026quot;tracepoint:syscalls:sys_enter_* { @[probe] = count(); }\u0026quot; Run a program from file Here we run a program named read.bt against the node ip-180-12-0-152.ec2.internal\nkubectl trace run ip-180-12-0-152.ec2.internal -f read.bt Run a program against a Pod That pod has a Go program in it that is at /caturday, that program has a function called main.counterValue in it that returns an integer every time it is called.\nThe purpose of this program is to load an uretprobe on the /caturday binary so that every time the main.counterValue function is called we get the return value out.\nSince kubectl trace for pods is just an helper to resolve the context of a container\u0026rsquo;s Pod, you will always be in the root namespaces but in this case you will have a variable $container_pid containing the pid of the root process in that container on the root pid namespace.\nWhat you do then is that you get the /caturday binary via /proc/$container_pid/exe, like this:\nkubectl trace run -e 'uretprobe:/proc/$container_pid/exe:\u0026quot;main.counterValue\u0026quot; { printf(\u0026quot;%d\\n\u0026quot;, retval) }' pod/caturday-566d99889-8glv9 -a -n caturday Running against a Pod vs against a Node In general, you run kprobes/kretprobes, tracepoints, software, hardware and profile events against nodes using the node/node-name syntax or just use the node name, node is the default.\nWhen you want to actually probe an userspace program with an uprobe/uretprobe or use an user-level static tracepoint (usdt) your best bet is to run it against a pod using the pod/pod-name syntax.\nIt\u0026rsquo;s always important to remember that running a program against a pod, as of now, is just a facilitator to find the process id for the binary you want to probe on the root process namespace.\nYou could do the same thing when running in a Node by knowing the pid of your process yourself after entering in the node via another medium, e.g: ssh.\nSo, running against a pod doesn\u0026rsquo;t mean that your bpftrace program will be contained in that pod but just that it will pass to your program some knowledge of the context of a container, in this case only the root process id is supported via the $container_pid variable.\nUsing a custom service account By default kubectl trace will use the default service account in the target namespace (that is also default), to schedule the pods needed for your bpftrace program.\nIf you need to pass a service account you can use the --serviceaccount flag.\nkubectl trace run --serviceaccount=kubectltrace ip-180-12-0-152.ec2.internal -f read.bt Executing in a cluster using Pod Security Policies If your cluster has pod security policies you will need to make so that kubectl trace can use a service account that can run privileged containers.\nThat service account, then will need to be in a group that uses the proper privileged PodSecurityPolicy.\nFirst, create the service account that you will use with kubectl trace, you can use a different namespace other than default, just remember to pass that namespace to the run command when you will use kubectl trace:\napiVersion:v1kind:ServiceAccountmetadata:name:kubectltracenamespace:defaultNow that we have a kubectltrace service account let\u0026rsquo;s create a Pod Security Policy:\napiVersion:policy/v1beta1kind:PodSecurityPolicymetadata:name:kubectltracespec:fsGroup:rule:RunAsAnyprivileged:truerunAsUser:rule:RunAsAnyseLinux:rule:RunAsAnysupplementalGroups:rule:RunAsAnyvolumes:- \u0026#39;*\u0026#39;allowedCapabilities:- \u0026#39;*\u0026#39;hostPID:truehostIPC:truehostNetwork:truehostPorts:- min:1max:65536Ok, this PodSecurityPolicy will allow users assigned to it to run privileged containers, kubectl trace needs that because of the extended privileges eBPF programs need to run with to trace your kernel and programs running in it.\nNow with a ClusterRoleBinding you bind the ClusterRole with the ServiceAccount, so that they can work together with the PodSecurityPolicy we just created.\nYou can change the namespace: default here if you created the service account in a namespace other than default.\napiVersion:rbac.authorization.k8s.io/v1kind:ClusterRolemetadata:name:kubectltrace-psprules:- apiGroups:- policyresources:- podsecuritypoliciesresourceNames:- kubectltraceverbs:- use---apiVersion:rbac.authorization.k8s.io/v1kind:ClusterRoleBindingmetadata:name:kubectltrace-pspsubjects:- kind:ServiceAccountname:kubectltracenamespace:defaultroleRef:apiGroup:rbac.authorization.k8s.iokind:ClusterRolename:kubectltrace-pspOK! Now that we are all set we can just run the program by specifying the service account we just created and it will use our pod security policy!\nkubectl trace run --serviceaccount=kubectltrace ip-180-12-0-152.ec2.internal -f read.bt If you used a different namespace other than default for your service account, you will want to specify the namespace too, like this:\nkubectl trace run --namespace=mynamespace --serviceaccount=kubectltrace ip-180-12-0-152.ec2.internal -f read.bt "});index.add({'id':3,'href':'/kubectl-trace/contributing/','title':"Contributing",'content':"Already pumped up to commit some code? Here are some resources to join the discussions in the IOVisor community and see what you want to work on.\n Mailing List: http://lists.iovisor.org/mailman/listinfo/iovisor-dev IRC: #iovisor at irc.oftc.net Slack #kubectl-trace in the Kubernetes Slack Kubectl Trace Issue Tracker: Github Issues  "});index.add({'id':4,'href':'/kubectl-trace/usage/architecture/','title':"Architecture",'content':"Since it is a kubectl plugin, kubectl-trace doesn\u0026rsquo;t require you to install any component directly to your Kubernetes cluster in order to execute your bpftrace programs, however when you point it to a cluster, it will schedule a temporary job there called trace-runner that executes the program.\nThis figure, shows the general idea:\n"});index.add({'id':5,'href':'/kubectl-trace/categories/','title':"Categories",'content':""});index.add({'id':6,'href':'/kubectl-trace/usage/further-reading/','title':"Further reading",'content':"kubectl-trace can run any bpftrace program, many of which can be found here:\n bpftrace One Liners bpftrace Reference Guide \u0026ldquo;official\u0026rdquo; bpftrace tools  "});index.add({'id':7,'href':'/kubectl-trace/','title':"kubectl-trace",'content':"kubectl-trace is a kubectl plugin that allows you to schedule the execution of tracing programs like bpftrace in your Kubernetes cluster.\n"});index.add({'id':8,'href':'/kubectl-trace/tags/','title':"Tags",'content':""});})();